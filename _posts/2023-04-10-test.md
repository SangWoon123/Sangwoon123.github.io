---
layout: post
title:  "JPA ch1~ch4"
--- 

  # SQL의 문제점
  - 개발자가 쿼리문을 하나하나 작성해야 한다.
  - 객체지향 개발을 위해 DB 조작이 복잡하다.
  - 객체 설계와 DB 간의 매핑 관계가 다르다.
  - 객체 지향적으로 모델링할수록 매핑 작업만 늘어난다.

    → <b>객체를 자바 컬렉션에 저장하는 것처럼 DB에 저장할 수는 없을까? → JPA (Java Persistence Orm)</b>

## JPA 에 대해

하이버네이트는 JPA의 구현체 중 하나로, 자바 객체와 DB의 테이블을 매핑해주는 기능을 제공합니다. JPA를 사용하면 객체 지향적인 코드를 작성하면서 DB 조작을 간단하게 처리할 수 있습니다. 하이버네이트는 JPA 표준을 준수하면서도 다양한 기능을 제공합니다.

JPA는 표준명세 (*표준명세 = 인터페이스모음)

- 구현체: 하이버네이트, EclipseLink, DataNucleus

### JPA를 사용해야하는이유

- SQL 중심적인 개발에서 객체 중심으로 개발
- 생산성

```jsx
저장: jpa.persistence(member)
조회: Member member=jpa.find(memberId)
수정: member.setName("변경할 이름")
삭제: jpa.remove(member)
```

- 유지보수

- 패러다임의 불일치 해결

  - JPA와 상속

    ```jsx
    개발자: jpa.persistence(album);
    Jpa: 개발자 코드를 뒤에서 query문을 자동으로 생성해서 처리해준다.
    ```

  - JPA와 연관관계

  - 신뢰할 수 있는 엔티티,계층

- 성능

  - 1차 캐시와 동일성 보장 ( ‘같은 데이터베이스 트랜잭션’ (조건) 안에서 SQL1번으로 두번의 조회를 할 수 있음 / 1차캐시는 데이터베이스 트랜잭션 단위로 짧은 캐시)
  - 트랜잭션을 지원하는 쓰기 지연 (모아서 한번에)

  ```jsx
  transaction.begin()
  
  em.persist(memberA);
  em.persist(memberB);
  em.persist(memberC);
  ```

  - 지연로딩 (Lazy Loading)

    - 지연로딩: 객체가 실제 사용될 때 로딩
    - 즉시로딩: JOIN SQL로 한번에 연관된 객체까지 미리조회

    → 왜 중요한가? 최적화 (ex) 1차적으로 지연로딩으로 개발후 즉시로딩적용)

    # JPA 시작

    jpa 구동방식

    Persistence에서 META-INF/xml에서 생성한 정보를 가지고 entityManagerFactory에서 돌려서 찍어내는 방식

    JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리언어 제공

    JPQL은 엔티티 객체를 대상으로 쿼리 (엔티티 메니저객체를 통해 쿼리 수행)

    JPA의 동작 방식

    1. Entity Class 작성

    - JPA가 관리하는 객체, 데이터베이스 테이블과 매핑되는 객체

    1. EntityManager 생성

    - EntityClass 와 데이터 베이스 간의 작업을 수행하는 역할 ( 역할 수행시 영속성 컨텍스트 사용)
    - EntityManager는 일시적으로 생성되고 해제되는 방식

    1. Persistence Context

    - EntityManager가 Entity 클래스와 데이터베이스 간 매핑을 처리할때 사용하는 컨텍스트

  ### 영속성 컨텍스트

  “엔티티를 영구 저장하는 환경”

  엔티티의 생명주기

  - 비영속
    - 영속컨텍스트를 사용하기 전 객체
  - 영속 (persist / find)
    - 비영속 객체를 컨텍스트에 넣어진 상태
    - 아직 DB에 저장되지 않은상태
  - 준영속 (detach / clear)
    - 엔티티를 영속성컨텍스트에서 제거
    - 영속성 컨테스트가 관리하지 않는 상태
  - 삭제 (remove)

  이점

  - 1차 캐시
  - 동일성 보장
  - 변경감지 (스냅샷)
  - 지연로딩

  ### 플러시

  영속성 컨텍스트의 변경내용(쿼리) 을 데이터 베이스에 반영

  플러시 발생

  - 변경 감지
  - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
  - 쓰기지연 SQL 저장소의 쿼리를 데이터 베이스에 전송

  ```jsx
  em.flush(); // comit까지 기다리지 않고 쿼리가 바로 DB에 반영 
  ```

  주의! ‘플러시’는 영속성 컨테스트를 비우는 것이 아니라 변경내용을 데이터 베이스에 동기화

  Q. 영속성 컨텍스트가 왜 필요한가?

  영속성 컨텍스트는 엔티티를 영구저장하기위한 환경을 제공 영속성 컨텍스트가 없다면 직접 DB에 접근해서 변경을 해야하는데 이는 성능상 불필요한 문제가 발생할 수 있다.

  ### ch4 객체와 테이블 매핑

  Entity:

  - 객체와 테이블 매핑
  - 데이터베이스 스키마 자동 생성

  Q. 왜 기본 생성자 필수일까?

  - JPA에서 엔티티를 생성할 때 기본 생성자가 필요한 이유는 JPA가 엔티티 객체를 생성할 때, 기본 생성자를 사용하기 때문입니다. 또한 프록시 객체를 만들기 위해서도 기본 생성자가 필요합니다. 만약 엔티티에 기본 생성자가 없을 경우, JPA는 reflection API를 사용하여 엔티티를 생성합니다. 하지만 reflection API를 사용하면 성능상의 문제가 발생할 수 있기 때문에 기본 생성자를 필수로 요구합니다.

  스키마 자동생성 -속성

  - create: 시작시 기존 테이블 종료 후 생성, 개발 초기 단계에서 사용
  - create-drop: 시작시 DB 생성 후 종료시 DB drop
  - update: 개발 초기 단계에서 사용, 테스트 서버
  - validate: 엔티티와 테이블이 정상 매핑되었는지 확인, 테스트 서버, 스테이징, 운영서버
  - none: 스테이징, 운영서버

```
System.out.println("HelloWordl");
```